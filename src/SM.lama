-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn(i) {
  case i of
      READ      -> sprintf("READ")
    | WRITE     -> sprintf("WRITE")
    | BINOP (s) -> sprintf("BINOP %s", s)
    | LD    (x) -> sprintf("LD %s", x)
    | ST    (x) -> sprintf("ST %s", x)
    | CONST (n) -> sprintf("CONST %d", n)
  esac
}

public fun showSM(prg) {
  map(fun (i) { showSMInsn(i) ++ "\n" }, prg).stringcat
}


-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval(cfg@[stk, stt, wld], instructions) {
  case instructions of
      { }     -> cfg
    | he : ta -> case he  of
        CONST (n)  -> eval([n:stk, stt, wld], ta)
      | READ       -> case readWorld(wld) of
        [value, world_final] -> eval([value:stk, stt, world_final], ta)
      esac
      | ST (x)     -> eval([tl(stk), stt <- [x, hd(stk)], wld], ta)
      | LD (x)     -> eval([stt(x):stk, stt, wld], ta)
      | WRITE      -> eval([tl(stk), stt, writeWorld(hd(stk), wld)], ta)
      | BINOP (op) -> case stk of
        y : t -> eval([(parseOp(op)(hd(t), y)):tl(t), stt, wld], ta)
      esac
    esac

  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM(input, insns) {
  eval([{ }, emptyState, createWorld(input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine instructions
fun compileExpr(ex) {
  case ex of
      Const (x)          -> { CONST(x) }
    | Var (c)            -> { LD(c) }
    | Binop (op, le, ri) -> compileExpr(le) +++ compileExpr(ri) +++ { BINOP(op) }
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM(stmt) {
  case stmt of
      Assn (n, ex) -> compileExpr(ex) +++ { ST(n) }
    | Seq (a, b)   -> compileSM(a) +++ compileSM(b)
    | Read (n)     -> { READ, ST(n) }
    | Write (ex)   -> compileExpr(ex) +++ { WRITE }
  esac
}
